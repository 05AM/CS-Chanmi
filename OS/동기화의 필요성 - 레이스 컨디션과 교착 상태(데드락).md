# ☀ 스레드 동기화 문제: Race Condition (경쟁 상태)

![Untitled](https://i.ibb.co/TLhzfP7/3-1-race-condition.png)

> 2개 이상의 프로세스 혹은 스레드가 공유 자원을 서로 사용하려고 경합(Race)하는 현상
> 
- 동시에 공유 자원에 접근할 수 있으면 자원의 일관성을 해치는 결과가 발생
    
    → 동시에 접근할 수 없도록 `상호 배제`(Mutual Exclusion) 조건
    
    → 여러 스레드가 하나의 스레드만이 차지할 수 있는 `락`(Rock)을 획들하기 위해 경합
    
- 하지만 상호배제를 하여도 문제가 발생할 수 있다.

## ☀ 교착 상태 (Deadlock)

> 공유 자원에 대한 요구가 엉켜서 자원 관리를 잘못하여 프로세스나 스레드가 자원의 락을 획득하기 위해 무한대기하는 것
> 
- `상호 배제` (Mutual Exclusion)
    - 두 개 이상의 프로세스 혹은 스레드가 동시에 한 공유자원에 접근할 수 없도록 하여 한 자원에 한 스레드만 접근할 수 있게 하는 것
    - 자원에 대한 배타적 통제권: 해당 자원을 나 자신만 쓰겠다고 하는 상황
    - **어느 스레드가 자원을 독점적으로 사용**하고 있어 다른 스레드가 자원에 접근하려고 락을 획득하기 위해 무한 대기하는 상황이 발생
- `점유 상태로 대기` (Hold and Wait)
    
    ![Untitled](https://i.ibb.co/NjdSWvR/3-2-hold-and-wait.png)
    
    - 공유 자원에 락을 획득하여 점유하고 있는 상태로, 다른 자원의 락을 획득하기 위해 대기하는 상황
    - 여러 개의 자원을 동시에 써야하는 경우, 락을 획득한 자원에 대한 처리는 끝났지만 **남은 자원의 락을 다른 스레드가 가지고 해제를 하지 않아서 무한정 대기**하는 상황이 발생할 수 있다.
    - 자신이 점유하고 있는 락도 해제할 수 없으니, **해당 락을 획득하기 위해 기다리는 다른 스레드들도 무한 대기**하는 ****상황 발생
- `비선점` (Non-preemption)
    - 다른 프로세스나 스레드가 자원을 선점하고 있어 자원을 가져올 방법이 없는 것
    - **어느 스레드가 공유 자원의 락을 획득하여 선점**하고 있다면, 그 공유 자원에 접근해야 하는 다른 스레드들은 락을 가져올 방법이 없기 떄문에 무한 대기하는 상황이 발생
- `순환형 대기` (Cilcular Wait)
    
    ![Untitled](https://i.ibb.co/X8qnV0Y/3-3-circular-wait.png)
    
    - 프로세스가 어느 자원을 점유하고 있고 다른 자원을 요청하여 대기하고 있는 상황에서 대기 상태가 순환적인 구조를 갖고 있는 것
    - **점유 상태로 대기가 순환적으로 발생한 상황**
    - 락을 해제하고 락을 획득하는게 순차적으로 돌아가지 않고, **어느 순간 모든 프로세스가 순환적으로 락을 획득하려고 대기**하여 모든 프로세스가 무한 대기에 놓인 상황이 발생

<br>

## ☀ 교착상태 해결 방안

### 🌕 예방(Prevention)

교착상태가 발생하지 않도록 사전에 시스템을 제어하는 방법으로 교착상태 발생의 네가지 조건 중에서 어느 하나를 제거한다. 단, 자원 낭비가 가장 심한 해결 방법이다.

- **상호 배제(Mutual Exclusion)부정**
    
    한번에 여러 개의 프로세스가 공유 자원을 사용할 수 있도록 한다.
    
- **점유 및 대기(Hold and Wait) 부정**
    
    프로세스가 실행되기 전 필요한 모든 자원을 할당하여 프로세스 대기를 없애거나 자원이 점유되지 않은 상태에서만 자원을 요구한다.
    
- **비선점(Non-preemption)부정**
    
    자원을 점유하고 있는 프로세스가 다른 자원을 요구할 때 점유하고 있는 자원을 반납하고, 요구한 자원을 사용하기 위해 기다린다.
    
- **순환형 대기(Circular Wait)부정**
    
    자원을 선형 순서로 분류하여 고유 번호를 할당하고, 각 프로세스는 현재 점유한 자원의 고유 번호보다 앞이나 뒤 어느 한쪽 방향으로만 자원을 요구하도록 한다.
    

### 🌕 **회피(Avoidance)**

교착상태가 발생할 가능성을 배제하지 않고 교착상태가 발생하면 적절히 피해나가는 방법으로, 주로 은행원 알고리즘(Banker's Algorithm)이 사용된다.

**은행원 알고리즘**

1. 은행원 알고리즘은 다익스트라가 제안한 기법으로, 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는데서 유래한 기법이다.
2. 각 프로세스에게 자원을 할당하여 교착상태가 발생하지 않으며 모든 프로세스가 완료될 수 있는 상태를 안전상태, 교착상태가 발생할 수 있는 상태를 불안전 상태라고 한다.
3. 은행은 자원을 할당한 후에도 안정 상태로 남아있는지 검사하여 안정 상태에 있으면 자원을 할당하고 그렇지 않으면 다른 프로세스들이 자원을 해제할 때까지 대기한다.
4. 은행원 알고리즘을 적용하기 위해서는 자원의 양과 사용자(프로세스) 수가 일정해야 한다.
5. 은행원 알고리즘은 프로세스의 모든 요구를 유한한 시간안에 할당하는 것을 보장한다.

### 🌕 탐지(Detection)

- 시스템에 교착상태가 발생했는지 점검하여 교착상태에 있는 프로세스와 자원을 발견한다.
- 교착상태 발견 알고리즘과 자원 할당 그래프 등을 사용 할 수 있다.

### 🌕 복구(Recovery)

교착상태를 일으킨 프로세스를 종료하거나 교착상태의 프로세스에 할당된 자원을 선점하여 프로세스나 자원을 회복한다.

### 🌕 프로세스 종료

교착상태에 있는 프로세스를 종료

교착상태에 있는 프로세스들을 하나씩 종료

### 🌕 자원선점

교착상태의 프로세스가 점유하고 있는 자원을 선점하여 다른 프로세스에게 할당하며, 해당 프로세스를 일시 정지시키는 방법이다.

우선순위가 낮은 프로세스, 수행된 정도가 적은 프로세스, 사용되는 자원이 적은 프로세스 등을 위주로 해당 프로세스의 자원을 선점한다.

<br>

## ☀ 기아 상태 (Starvation)

> 스레드들에게 우선 순위를 부여하여 공유 자원에 접근할 때, 우선순위가 낮은 스레드가 소외되어 아무 일도 하지 못하는 상태
> 
- `데드락` vs `기아상태`
    - `데드락`: 공유자원에 대한 요구가 엉켜서 모든 프로세스가 락을 획득하기 위해 기다리는 것
    - `기아상태`: 우선순위가 낮은 스레드가 공유 자원에 접근하기 위해 대기하는 상태에서 우선순위가 높은 스레드가 지속적으로 접근하여 **순서가 밀려 처리를 못하는 상태**
- 예시 상황
    - 공유자원이 1개, 스레드 4개
    - 3개의 스레드는 우선순위가 높고, 1개의 스레드는 우선순위가 낮음
    - 우선순위가 높은 스레드들이 번갈아가며 모든 시간을 공유 자원에 접근하는 경우
    - 우선순위가 낮은 스레드는 자원에 접근하기 위해 대기하고 있지만, 계속 우선순위가 높은 스레드가 다시 접근하려고 한다면 양보해야 한다.
    
    ⇒ **우선순위가 낮은 스레드는 자원에 접근하지 못하고 대기만 해야하는 상황**
  
<br>

## ☀ 라이브락 (LiveLock)

![Untitled](https://i.ibb.co/vzMq4kZ/1-5-livelock.png)

> 스레드들이 동시에 실행되면서 락의 해제와 획득을 반복하면서 정상적으로 동작하는 것처럼 보이지만, 사실상 아무것도 못하고 무한 반복중인 상황
> 
- `데드락`과 비슷한 결과를 가져오지만 다른 과정을 통해 발생하는 문제
- 데드락을 피하기 위해 프로세스가 락을 획득하지 못할 경우 대기 상태로 빠지지 않도록 하고, 자신이 획득한 락을 해제시켜 다른 프로세스가 자신이 점유하고 있던 자원에 접근할 수 있도록 처리한 후 다시 시작한다.
- 다른 프로세스와 이 과정이 순환적으로 일어나게 되면 이 두 프로세스는 서로 아무것도 하지 못하는 상황이 발생하여 결국 데드락과 같은 결과를 가져온다.
- [그림] 설명
    
    프로세스 1과 2가 동시에 실행되어 1~3번의 과정이 무한반복하게 되면 라이브락의 결과를 가져온다.

<br>

# 참고 자료

[[OS] 스레드 동기화 문제 - Race Condition, Deadlock, Starvation, Livelock](https://cheetile.tistory.com/entry/OS-스레드-동기화-문제-Race-Condition-Deadlock-Starvation-Livelock)

[경쟁상태(Race Condition)와 교착상태(Deadlock)란?](https://velog.io/@mooh2jj/교착상태Deadlock이란)
