## ☀️ CPU 스케줄링

> 언제 어떤 프로세스에 CPU를 할당할지 결정하는 작업
> 
- 다중 프로그램 운영체제에서 여러 프로세스나 스레드에 CPU 사용 시간을 할당하는 방법
- CPU 이용률을 최대화하여 효율성을 극대화시키기 위하여 항상 실행중인 프로세스를 가지게 한다.
- 어떤 프로세스가 대기해야 할 경우, 운영체제는 CPU를 그 프로세스로부터 회수해 다른 프로세스에 할당한다.
- 최신 운영체제는 프로세스가 아닌, 커널 수준의 스레드를 스케줄링 한다.

### 🌕 CPU 스케줄링의 기본 개념

이용률을 최대화하기 위하여 CPU 스케줄러는 준비 큐에 있는 프로세스 중 하나를 선택하여 실행한다. 이 과정에서 `선점형 및 비선점형 스케줄링`, `디스패처`, 그리고 `CPU-I/O 버스트 사이클` 등의 개념이 사용된다.

### 🌕 **CPU 스케줄링의 목적**

- **효율성**: CPU가 가능한 한 바쁘게 유지되도록 한다.
- **공정성**: 모든 프로세스가 공정한 CPU 시간을 얻는다.
- **응답 시간 최소화**: 사용자의 요청에 대한 빠른 응답을 보장한다.
- **대기 시간 최소화**: 프로세스가 CPU를 기다리는 시간을 줄인다.
- **처리량 최대화**: 단위 시간당 최대한 많은 작업을 처리한다.

### 🌕 **CPU 스케줄링 결정 상황**

1. 실행(running) 상태에서 대기(waiting) 상태로 전환(switching)될 때 ( ex : I/O 발생 )
2. 실행(running) 상태에서 준비(ready) 상태로 전환(switching)될 때 ( ex : intterupt 발생 )
3. 대기(waiting) 상태에서 준비(ready) 상태로 전환(switching)될 때 ( ex : I/O 완료 시 )
4. 종료(Terminated)될 때

**1번과 4번 상황에서만** 스케줄링이 발생하는 것을 `비선점형`(non-preemptive) 스케줄링이라고 한다. 이외의 모든 스케줄링은 `선점형`(preemptive) 스케줄링이라고 한다.

<br>

## ☀️ CPU 스케줄링의 구현 방식

### 🌕 선점형 스케줄링 ****(Preemptive Scheduling)****

- 선점형 스케줄링에서는 운영체제가 현재 실행 중인 프로세스를 중단시키고 다른 프로세스로 전환할 수 있다. 이 전환은 프로세스의 실행 시간, 우선순위, 시스템의 전반적인 상태 등에 따라 결정된다.
- 프로세스가 CPU를 할당받은 상태에서도 우선 순위가 높은 다른 프로세스가 도착하면 CPU를 빼앗길 수 있다.
- **특징**
    - **동적**: 시스템 상태가 변함에 따라 프로세스 간의 전환을 자유롭게 할 수 있다.
    - **응답성**: 시스템이 사용자의 요구나 외부 이벤트에 빠르게 반응할 수 있다.
    - **시간 공유**: 다수의 사용자나 프로세스가 동시에 시스템을 사용하는 환경에서 효과적이다.
    - **복잡성**: 스케줄러 설계가 복잡하고, 자원 관리가 어려울 수 있다.
    - **높은 오버헤드**: 잦은 문맥 교환으로 오버헤드(Overhead)가 커질 수 있다.
    - **독점 방지**: CPU 처리 시간이 매우 긴 프로세스의 CPU 사용 독점을 막을 수 있어 효율적인 운영이 가능하다.
- **예시**
    - **라운드 로빈(Round Robin)**: 정해진 시간 동안만 프로세스를 실행하고, 시간이 끝나면 다음 프로세스로 전환
    - **우선순위 기반 스케줄링**: 높은 우선순위를 가진 프로세스에 CPU를 우선 할당

### 🌕 비선점형 스케줄링 ****(Nonpreemptive Scheduling)****

- 비선점형 스케줄링에서는 프로세스가 CPU를 한번 할당받으면, 그 프로세스가 종료되거나 대기 상태로 전환될 때까지 CPU를 계속 사용한다.
- **특징**
    - **단순성**: 스케줄러 설계가 선점형에 비해 단순하다.
    - **자원 활용**: 프로세스가 CPU를 점유한 상태에서 다른 자원을 기다릴 때, CPU의 이용률이 낮아질 수 있다.
    - **응답성 제한**: 긴 작업을 수행한느 프로세스가 CPU를 점유하고 있으면, 다른 프로세스는 그 작업이 끝날 때까지 기다려야 한다.
- **예시**
    - **선입 선처리(FCFS, First-Come First-Served)**: 먼저 준비 큐에 도착한 프로세스에게 CPU를 할당
    - **최단 작업 우선(SJF, Shortest Job First)**: 예상 실행 시간이 가장 짧은 프로세스에게 CPU를 우선 할당

### 🌕 비교

- **응답성**
    
    선점형은 비선점형에 비해 더 빠른 응답 시간을 제공한다.
    
- **설계 복잡성**
    
    선점형은 비선점형보다 스케줄러 설계가 복잡하다.
    
- **자원 활용**
    
    비선점형은 CPU가 유휴 상태에 있을 가능성이 더 높다.
    
- **적합한 환경**
    
    **선점형**은 시분할 시스템이나 멀티태스킹 환경에 적합하며, **비선점형**은 배치 처리 시스템이나 단순한 시스템에 적합하다.
    

<aside>
➡️ `선점형`은 실시간 시스템이나 공유 환경에서 높은 성능을 제공하는 반면, `비선점형`은 단순한 시스템이나 배치 처리에 적합하다.

</aside>

<br></br>

## ☀️CPU 스케줄링 알고리즘

### 1. **선입 선처리 (FCFS - First Come, First Served)**

가장 간단한 형태로, 먼저 요청하는 프로세스에 CPU를 할당한다.

- 비선점형(Non-preemptive) 스케줄링
- 작성이 간단하고 이해하기 쉬움
- 평균 대기 시간(Average Waiting Time)이 길어질 수 있음
- 응답 시간(Response Time)이 길어질 수 있음
- 반환시간(Turnaround Time) 면에서는 좋을 수 있음
- Convoy Effect(호위 효과)가 발생할 수 있음

[**FCFS 예시]**

![Untitled](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fcj1eAz%2FbtrwVseqDoP%2FkywQBfZVaeLRcEJ7nFNXk0%2Fimg.png)


### 2. **최단 작업 우선 (SJF - Shortest Job First)**

CPU 버스트 길이가 가장 짧은 프로세스에 우선적으로 CPU를 할당한다.

- 비선점형과 선점형 존재
- **비선점형**에서는 실행되고 있는 프로세스는 끝까지 실행
- **선점형**에서는 현재 실행되고 있는 프로세스의 남은 시간보다 도착한 다음 프로세스가 더 빨리 끝날 수 있는 프로세스라면, 다음 프로세스를 실행하도록 바꾼다.
    
    → **SRTF**(Shortest Remaining Time First)라고도 부른다.
    
- 평균 대기 시간을 줄일 수 있음
- 다음 프로세스의 CPU burst time을 예측하는 것이 어렵다는 문제가 존재

[**비선점형 SJF 예시]**

![Untitled](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FLvUVD%2FbtrwVsSWLbJ%2FoIOaF3SBtE9Gd87sWqjGWK%2Fimg.png)


[**선점형 SJF 예시]**

![Untitled](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FL2iRd%2FbtrwXz49BtP%2FucHEyokTcjfydBSZdogOhK%2Fimg.png)


### 3. 우선순위 스케줄링 (Priority)

각 프로세스에 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스에 CPU를 할당한다.

- 선점형과 비선점형 존재
- 다음 CPU burst time이 우선순위인 것처럼 작동하므로 SJF도 Priority 스케줄링이라고 할 수 있음
- `기아 문제`(Starvation)가 발생 가능
    
    → `노화`(aging) 기법 사용
    
    : 대기 중인 프로세스의 대기 시간에 비례하여 우선순위를 높여주는 기법
    

[**Priority 스케줄링 예시]**

![Untitled](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FA4IZf%2FbtrwVrs2Cux%2Fs1k5EWSxBkYRMgULlr4F70%2Fimg.png)

### 4. 라운드 로빈 (RR - Round Robin)

각 프로세스에 동일한 시간 할당량을 부여하고, 시간 할당량이 완료되면 다음 프로세스로 넘어간다.

- 할당 시간 내에 처리를 완료하지 못하면 다음 프로세스로 넘어가는 선점형 방식
- n개의 프로세스가 있을 때 할당 시간을 q로 설정하면, 어떤 프로세스도 (n-1)q 시간 이상을 기다리지 않아도 됨
- 응답 시간이 빠르다는 장점
- q가 커진다면 FCFS처럼 작동
- q가 매우 작아지면 process sharing이라고 부름
    
    → n개의 프로세스가 프로세서 속도의 1/n 씩으로 작동함을 의미
    

**[RR 예시]**

![Untitled](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FoVKvq%2Fbtrw2NV85g2%2FymVM3yVGOHXr9GqSkkZPD0%2Fimg.png)


### 5. 다단계 큐 스케줄링 (**Multi-Level Queue)**

프로세스를 여러 큐로 분류하고, 각 큐마다 다른 스케줄링 알고리즘을 적용한다.

- **각 큐 사이에 프로세스들이 이동 불가능**
- 일반적으로 **Foreground 프로세스**들은 `RR`을 사용하고, **Background 프로세스**는 `FCFS`를 사용한다.
- 기아(Starvation) 문제가 발생 가능
- 보통 CPU 시간의 80%는 Foreground의 RR, 20%는 Background의 FCFS에 할당

![Untitled](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FXMWpH%2Fbtrw5DyJTF7%2FO0qPFx4uqpTJkWE0fD8kv0%2Fimg.png)

### 6. **다단계 피드백 큐 스케줄링** (**Multi-Level Feedback Queue)**

프로세스가 큐 사이를 이동할 수 있으며, 프로세스의 특성에 따라 동적으로 큐를 변경한다.

![Untitled](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbbMjai%2FbtrwVsZNvAn%2FD8SiDqyVytoNg1usFOeBw0%2Fimg.png)

<br>

## ☀️CPU 스케줄링 평가 기준

1. **CPU 이용률**(CPU utilization)
    - 시간당 CPU를 사용한 시간의 비율
    - 프로세서를 항상 실행상태로 유지하도록 해야 한다.
2. **처리율**(Throughput)
    - 시간당 처리한 작업의 비율
    - 단위 시간당 완료되는 작업 수가 많도록 해야 한다.
3. **반환시간**(Turnaround Time)
    - 프로세스가 생성된 후 종료되어 사용하던 자원을 모두 반환하는 데까지 걸리는 시간
    - 작업이 준비 큐(ready queue)에서 기다린 시간부터 CPU에서 실행된 시간, I/O 시간의 합이다.
4. **대기시간**(Waiting Time)
    - 대기열에 들어와 CPU를 할당받기 까지 기다린 시간
    - 준비 큐에서 기다린 시간의 총합
5. **반응시간**(Response Time)
    - 대기열에서 **처음으로** CPU를 얻을 때까지 걸린 시간
    - 대기시간과 비슷하지만 다른 점은, 대기시간은 준비 큐에서 기다린 모든 시간을 합친 것이지만 반응 시간은 CPU를 할당받은 최초의 순간까지 기다린 시간 한 번만을 측정한다.

<aside>
➡️ CPU 이용률과 처리율은 극대화하고, 반환시간, 대기시간, 반응시간을 줄이는 것이 일반적으로 좋다.

</aside>

<br></br>

## ☀️ 디스패처

> CPU 스케줄링 시스템에서 중요한 역할을 하는 구성요소로, 프로세스 또는 스레드의 관리와 관련된 작업을 수행
> 

### 🌕 **디스패처의 주요 기능**

1. **문맥 교환 (Context Switching)**
    
    현재 실행 중인 프로세스(또는 스레드)의 상태를 저장하고, 다음에 실행될 프로세스의 상태를 불러오는 문맥 교환을 수행한다. 이를 통해 CPU가 다양한 프로세스 사이에서 빠르게 전환할 수 있다.
    
2. **프로세스 전환 (Process Switching)**
    
    준비 상태의 프로세스 중 하나를 선택하고, 이를 실행 상태로 전환한다. 이 과정은 CPU 스케줄러가 결정한 순서에 따라 진행된다.
    
3. **사용자 모드로의 전환**
    
    프로그램이 실행될 때, 디스패처는 시스템의 실행 모드를 커널 모드에서 사용자 모드로 전환한다. 이는 프로세스가 시스템 자원에 대한 제한된 접근 권한을 가지고 실행되도록 한다.
    
4. **프로그램 카운터의 설정**
    
    디스패처는 프로그램 카운터를 다음 실행할 명령어의 주소로 설정한다. 이를 통해 CPU는 적절한 위치에서 프로세스의 실행을 시작할 수 있다.
    

### 🌕 **디스패치 지연 (Dispatch Latency)**

- 디스패처가 한 프로세스를 중단하고 다른 프로세스를 시작하기까지 걸리는 시간
- 이 지연 시간은 가능한 짧아야 하며, 시스템의 전반적인 성능에 영향을 미친다.

<br>

## ☀️ ****CPU-I/O 버스트 사이클****

- 컴퓨터 시스템에서 프로세스의 실행 패턴을 설명하는 데 사용되는 개념
- 프로세스가 CPU 버스트와 I/O 버스트 사이를 번갈아 가며 진행되는 패턴

### 🌕 CPU 버스트 (CPU Burst)

> 프로세스가 CPU를 사용하여 연산을 수행하는 시간
> 
- 예를 들어, 계산을 수행하거나 메모리에서 데이터를 가져오는 작업이 CPU 버스트에 해당한다.
- 일반적으로 CPU 버스트는 짧은 시간 동안 발생한다. 그러나 어떤 프로세스는 복잡한 계산을 수행하기 때문에 긴 CPU 버스트를 경험할 수도 있다.

### 🌕 ****I/O 버스트 (I/O Burst)****

> 프로세스가 입출력 작업을 수행하는 시간
> 
- 파일 시스템에 데이터를 쓰거나 네트워크를 통해 데이터를 전송하는 등의 작업을 포함한다.
- I/O 버스트는 프로세스가 CPU를 사용하지 않고, 데이터 입출력을 기다리는 시간으로, 이 때 CPU는 다른 프로세스를 처리할 수 있다.

### 🌕 CPU-I/O 버스트 사이클

1. **교대 현상**
    
    대부분의 프로세스는 CPU 버스트와 I/O 버스트 사이를 번갈아 가며 전환한다. 이 패턴을 CPU-I/O 버스트 사이클이라고 한다.
    
2. **시스템 성능에 미치는 영향**
    
    CPU와 I/O 장치의 사용 효율성은 이러한 버스트 사이클의 패턴에 크게 의존한다.
    
    예를 들어, **많은 프로세스가 I/O 버스트를 경험**하면, CPU는 비활동적 상태가 될 수 있으며, 이는 **시스템 자원의 낭비**로 이어질 수 있다.
    
3. **스케줄링 최적화**
    
    CPU 스케줄러는 이러한 **버스트 사이클의 특성을 고려하여 프로세스를 효율적으로 스케줄**한다.
    
    예를 들어, 짧은 CPU 버스트를 가진 프로세스에 우선순위를 주어 빠른 반응 시간을 제공할 수 있습니다.
    

<aside>
➡️ CPU와 I/O 장치의 균형 잡힌 사용을 통해 시스템의 처리량과 반응 시간을 개선할 수 있다.

</aside>

<br></br>

## ☀️ **컨텍스트 스위칭**

- CPU 스케줄링 과정에서 발생하는 프로세스 전환을 컨텍스트 스위칭이라고 한다. 이는 상당한 오버헤드를 유발할 수 있으므로, 효율적인 스케줄링이 중요하다.

<br>

## ☀️ CPU 스케줄링 - **실시간 스케줄링**

> 컴퓨터 시스템이 자원(특히 CPU)을 프로세스나 스레드에 할당하는 방법으로, 작업이 정해진 시간 제약 내에 완료되도록 보장하는 것을 목표한다.
> 
- 실시간 시스템에서는 작업의 정시성이 중요한데, 이는 해당 작업이 정해진 시간 내에 완료되어야 함을 의미한다.
- 이를 위해 실시간 운영 체제는 보다 엄격한 스케줄링 요구 사항을 가진다.

### 🌕 실시간 스케줄링 알고리즘

1. **Rate Monotonic Scheduling (RMS)**
    - 고정 우선순위 스케줄링 방법
    - 주기적인 작업에 사용
    - 주기가 짧은 작업에 높은 우선순위를 부여
2. **Earliest Deadline First (EDF)**
    - 동적 우선순위 스케줄링 방법
    - 각 작업에 대한 마감시간에 따라 우선순위를 할당
    - 마감시간이 가장 빠른 작업에 가장 높은 우선순위를 부여
3. **Fixed Priority Preemptive Scheduling**
    - 각 작업에 고정된 우선순위를 부여하고, 높은 우선순위의 작업이 실행 중일 때 낮은 우선순위의 작업은 중단

### 🌕**실시간 스케줄링의 특징**

- **시간 제약의 준수**: 실시간 작업은 정해진 시간 내에 완료되어야 한다.
- **자원 관리**: 제한된 자원을 효율적으로 관리하여 모든 실시간 작업이 시간 제약을 충족할 수 있도록 한다.
- **우선순위 할당**: 작업에 따라 적절한 우선순위를 할당하고 이를 기반으로 스케줄링한다.
- **선점과 비선점**: 실시간 시스템은 선점형 또는 비선점형 스케줄링 방법을 사용할 수 있다.

<br>

## ☀️ 참고 자료

[[운영체제] CPU 스케줄링 알고리즘 정리 및 요약 | FCFS, SJF, Round Robin](https://code-lab1.tistory.com/45)

[CPU 스케줄러 전략 (FCFS, SJF, HRN, SRT, Round Robin, Multi-Level Queue)](https://aeroej.tistory.com/143)
