# ☀️ 메모리 관리

다중 프로그래밍 시스템에서 여러 프로세스를 수용하기 위해 주기억 장치(RAM)을 동적 분할하는 메모리 관리 작업이 필요한다.

→ 하드 디스크에 있는 프로그램을 어떻게 주기억 장치에 적재할 것인가

<br>

# ☀️ 연속 메모리 관리

> 하나의 프로그램 전체가 하나의 메모리 공간에 연속적으로 할당된다.
> 
- `고정 분할 기법`: 주기억 장치가 고정된 파티션으로 분할 → **내부 단편화** 발생
- `동적 분할 기법`: 파티션들이 동적 생성되며 자신의 크기와 같은 파티션에 적재 → **외부 단편화** 발생

<aside>
➡️ 연속 메모리 관리 기법을 사용할 경우, 단편화 현상이 발생한다.

</aside>

## 🌕 단편화 (Fragmentation)

> 메모리의 빈 공간 또는 자료가 여러 조각으로 나뉘는 현상
> 

프로세스들이 메모리에 적재되고 적재되는 일이 반복되면, 프로세스들이 차지하는 메모리 틈 사이에 사용하지 못할만큼의 빈 공간이 늘어나게 된다.

- **내부 단편화**
    - 프로세스가 사용하는 메모리 공간에 남는 부분
    - 프로세스가 요청한 양보다 더 많은 메모리를 할당할 때 발생하며, 고정 크기의 메모리 분할 자유 공간과 프로세스가 사용하는 공간의 크기 차이를 의미한다.

![Untitled](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb2GvRX%2FbtrmSxVFvgJ%2Fxp6TfIJteQy8N790KJFyj1%2Fimg.png)

- **외부 단편화**
    - 전체 메모리 공간 중 사용하지 못하게 되는 부분
    - 메모리 할당 및 해제 작업의 반복으로 적재된 프로그램 사이에 작은 빈 공간이 중간 중간 존재할 수 있다. 이렇게 사용하지 않는 메모리가 존재해 총 메모리 공간은 충분하지만 실제로는 할당할 수 없는 상황이 발생한다.
    - 이를 해결하기 위해 압축을 이용하여 프로세스가 사용하는 공간을 한쪽으로 몰 수 있지만, 작업 효율이 좋지 않다.

![Untitled](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdN6x55%2FbtrmQ3VieHq%2FDp3nzzkzPYqWxSXpZLDTV0%2Fimg.png)

<br>

# ☀️ 불연속 메모리 관리

> 프로그램의 일부가 연속되지 않은 서로 다른 주소 공간에 할당될 수 있는 기법
> 

단편화 문제를 해결하기 위해 제시된 기법으로, 외부 단편화 해소를 위한 `페이징`과 내부 단편화 해소를 위한 `세그멘테이션`으로 나뉜다.

<br>

# ☀️ 페이징 (Paging)

> 프로세스를 일정한 크기의 페이지로 분할해서 메모리에 적재하는 방식
> 
- `프레임`
    - 물리적 메모리(주기억 장치, RAM)를 나누는 고정 크기의 기본 단위
- `페이지`
    - 가상 메모리를 나누는 고정 크기의 기본 단위
    - 프레임과 같은 크기의 가상 메모리 내 프로세스 조각
    - ex) 가상 메모리: 책 / 페이지 : 책 한 페이지

프레임의 크기는 페이지의 크기와 일치한다. 이는 가상 메모리의 페이지가 물리적 메모리의 프레임에 매핑될 수 있도록 하기 위함이다.

<aside>
➡️ 하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 없애는 메모리 관리 방법이다.

</aside>

## 🌕 페이징 테이블 (Paging Table)

![Untitled](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbisAIZ%2FbtrmMggPQSL%2FngNzgHoxMnwSU5boElqrA0%2Fimg.png)


- 개별 페이지는 순서에 상관없이 물리 메모리에 있는 프레임에 매핑되어 저장된다.
- 즉, 모든 프로세스는 하나의 페이징 테이블을 가지고 있으며, 여기에는 메인 메모리에 적재되어 있는 페이지 번호와 해당 페이지가 위치한 메인 메모리의 시작 주소가 있다.
- 이를 통해 하나의 프로세스를 나눈 가상 메모리 페이지들이 각각 실제 메인 메모리의 어디 프레임에 적재되어 있는지 알 수 있다.

![Untitled](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FsntgC%2FbtrmRiq813s%2F5JpzqIPO4melxoEkgBrczK%2Fimg.png)


위 PMT(Page Mapping Table, 페이징 테이블)에서는 P1 프로세스의 0번째 페이지가 메인 메모리의 5번째 프레임에 있는 것을 알 수 있다.

## 🌕 논리 주소와 페이지 테이블

앞서 메모리 관리 장치 (MMU, Memory Management Unit)는 가상 주소(논리 주소)를 이용해 실제 데이터가 담겨 있는 주소로 변환해준다고 하였다.

![Untitled](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcFvXra%2FbtrmQ3A1UO8%2FtzbK62Q2uBQgxnui3wc1KK%2Fimg.png)

논리 주소는 <page, offset> 과 같은 형태로 구성되는데, 이를 이용해 물리 주소로 변환해주는 것이다.

**[가상 주소를 물리 주소로 변환하는 전체 과정]**

![Untitled](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FpCyca%2FbtrmKBsv1c2%2FuenUi303boQMKSwN0jV1C1%2Fimg.png)


## 🌕 페이징의 장단점

### 장점

논리 메모리는 물리 메모리에 저장될 때 연속되어 저장될 필요가 없고, 물리 메모리의 남는 프레임에 적절히 배치되기 때문에 외부 단편화가 생기지 않는다.

### 단점

내부 단편화 문제가 발생할 수 있다. 페이지 단위를 작게하면 해결할 수 있지만, 페이지 매핑 과정이 복잡해져 오히려 비효율적이다.

![Untitled](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbfJMnj%2FbtrmLByKsGA%2FOwYaGZe36XOm25M49iRrz0%2Fimg.png)

<br>

# ☀️ 세그멘테이션 (Segmentation)

> 프로세스를 물리적 단위인 페이지가 아닌 논리적 단위인 세그먼트로 분할해서 메모리에 적재하는 식
> 
- `세그먼트`: 가상 메모리를 서로 크기가 다른 논리적 단위로 분할한 것
- ex) 페이징: 돼지를 같은 크기로 잘라서 보관 / 세그멘테이션: 부위 별로 잘라서 보관

⇒ 의미가 같지 않은 논리적 내용을 기준으로 프로그램을 분할하기 때문에 크기가 같지 않다.

## 🌕 세그먼트 테이블

분할 방식을 제외하면 페이징과 세그멘테이션은 동일한 방식이기 때문에 매핑 테이블의 동작 방식도 동일하다. 다만, 논리 주소의 앞 비트들은 페이징 번호가 아니라 세그먼트 번호가 된다.

즉, <segment, offset>의 형태로 구성되며, 세그먼트 번호를 통해 세그먼트의 기준(세그먼트의 시작 물리 주소)와 한계(세그먼트의 길이)를 파악할 수 있다.

## 🌕 세그멘테이션의 장단점

### 장점

- 내부 단편화 문제가 해소된다.
- 보호와 공유 기능을 수행할 수 있다. 프로그램의 중요한 부분과 중요하지 않은 부분을 분리하여 저장할 수 있고, 같은 코드 영역은 한 번에 저장할 수 있다.

### 단점

- 외부 단편화 문제가 생길 수 있다.

<br>

# ☀️ 페이징과 세그멘테이션

## 🌕 단순 페이지

- 각 프로세스는 프레임과 같은 길이를 가진 균등 페이지로 나뉜다.
- 외부 단편화가 생기지 않는다.
- 내부 단편화가 존재할 수 있다.

## 🌕 단순 세그멘테이션

- 각 프로세스는 여러 세그먼트로 나뉜다.
- 내부 단편화가 생기지 않는다.
- 메모리 효율을 개선한다.
- 동적 분할을 통한 옵버헤드가 감소한다.
- 외부 단편하가 존재할 수 있다.

## 🌕 가상 메모리 페이징

- 단순 페이징과 비교해 프로세스 페이지 전부를 로드할 필요가 없다.
- 필요한 페이지가 있으면 나중에 자동으로 불러 들인다.
- 외부 단편화가 생기지 않는다.
- 복잡한 메모리 관리로 오버헤드가 발생할 수 있다.
- 
<br>

# ☀️ 참고 자료

[[운영체제] 페이징과 세그멘테이션](https://steady-coding.tistory.com/524)
